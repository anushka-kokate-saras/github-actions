name: Deploy Tenant-specific Lambda Functions

on:
  push:
    branches:
      - '*'  # Trigger on all branch pushes
  workflow_dispatch:  # Allow manual triggers

jobs:
  deploy:
    runs-on: ubuntu-latest
    # Skip deployment for the main branch if you want
    if: github.ref != 'refs/heads/main'

    env: 
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_DEFAULT_REGION: "ap-northeast-3"

    steps:
      - uses: actions/checkout@v2

      - name: Install zip tool
        run: sudo apt-get install -y zip

      - name: Install or Update AWS CLI
        run: |
          curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
          unzip awscliv2.zip
          sudo ./aws/install --update

      - name: Deploy Tenant-specific Lambda Functions
        run: |
            # Extract tenant ID from branch name and sanitize it
            TENANT_ID=$(echo "${{ github.ref_name }}" | tr -cd '[:alnum:]' | tr '[:upper:]' '[:lower:]')
            ROLE_NAME="LambdaRole_${TENANT_ID}"
            
            echo "Deploying for tenant: $TENANT_ID"

            # Function to create IAM role if not exists
            create_iam_role() {
              ROLE_EXISTS=$(aws iam get-role --role-name "$ROLE_NAME" --query 'Role.RoleName' --output text 2>/dev/null || echo "NO")

              if [ "$ROLE_EXISTS" = "NO" ]; then
                echo "Creating IAM role $ROLE_NAME..."
                aws iam create-role --role-name "$ROLE_NAME" \
                  --assume-role-policy-document '{
                    "Version": "2012-10-17",
                    "Statement": [{
                      "Effect": "Allow",
                      "Principal": {"Service": "lambda.amazonaws.com"},
                      "Action": "sts:AssumeRole"
                    }]
                  }'

                aws iam attach-role-policy --role-name "$ROLE_NAME" \
                  --policy-arn "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
                aws iam attach-role-policy --role-name "$ROLE_NAME" \
                  --policy-arn "arn:aws:iam::aws:policy/AmazonSQSFullAccess"
                
                # Wait for role propagation
                echo "Waiting for IAM role propagation..."
                sleep 15
              else
                echo "Using existing IAM role $ROLE_NAME"
              fi
            }

            for dir in ./lambdaFunctions/*/; do
              CONFIG_FILE="${dir}config.json"
              
              # Read base configuration
              BASE_FUNCTION_NAME=$(jq -r '.functionName' "$CONFIG_FILE")
              RUNTIME=$(jq -r '.runtime' "$CONFIG_FILE")
              TIMEOUT=$(jq -r '.timeout' "$CONFIG_FILE")
              MEMORY_SIZE=$(jq -r '.memorySize' "$CONFIG_FILE")
              
              # Create tenant-specific function name
              FUNCTION_NAME="${TENANT_ID}_${BASE_FUNCTION_NAME}"
              
              # Add tenant-specific environment variables
              BASE_ENV_VARS=$(jq -r '.environmentVariables' "$CONFIG_FILE")
              TENANT_ENV_VARS=$(echo "$BASE_ENV_VARS" | jq ". + {TENANT_ID: \"$TENANT_ID\"}" | 
                               jq 'to_entries | map("\(.key)=\(.value)") | join(",")')
              
              echo "Deploying tenant-specific function: $FUNCTION_NAME"

              # Create deployment package
              zip -r "${FUNCTION_NAME}.zip" "${dir}" -x "${dir}config.json"

              # Check if function exists
              FUNCTION_EXISTS=$(aws lambda get-function --function-name "$FUNCTION_NAME" 2>/dev/null || echo "NO")

              if [ "$FUNCTION_EXISTS" = "NO" ]; then
                echo "Creating new Lambda function $FUNCTION_NAME..."
                create_iam_role

                aws lambda create-function \
                  --function-name "$FUNCTION_NAME" \
                  --runtime "$RUNTIME" \
                  --role "arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/$ROLE_NAME" \
                  --handler "index.handler" \
                  --timeout "$TIMEOUT" \
                  --memory-size "$MEMORY_SIZE" \
                  --environment "Variables={$TENANT_ENV_VARS}" \
                  --zip-file "fileb://${FUNCTION_NAME}.zip" \
                  --tags "Tenant=$TENANT_ID"
              else
                echo "Updating existing Lambda function $FUNCTION_NAME..."
                
                # Update function code
                aws lambda update-function-code \
                  --function-name "$FUNCTION_NAME" \
                  --zip-file "fileb://${FUNCTION_NAME}.zip"

                # Update configuration with retries
                RETRY_COUNT=0
                while [ $RETRY_COUNT -lt 5 ]; do
                  if aws lambda update-function-configuration \
                    --function-name "$FUNCTION_NAME" \
                    --timeout "$TIMEOUT" \
                    --memory-size "$MEMORY_SIZE" \
                    --environment "Variables={$TENANT_ENV_VARS}"; then
                    break
                  fi
                  RETRY_COUNT=$((RETRY_COUNT+1))
                  echo "Retrying configuration update... ($RETRY_COUNT/5)"
                  sleep 10
                done
              fi

              # Handle SQS triggers
              SQS_ENABLED=$(jq -r '.sqsTrigger.enabled' "$CONFIG_FILE")
              if [ "$SQS_ENABLED" = "true" ]; then
                BASE_QUEUE_ARN=$(jq -r '.sqsTrigger.eventSourceArn' "$CONFIG_FILE")
                TENANT_QUEUE_ARN="${BASE_QUEUE_ARN%.*}_${TENANT_ID}.fifo"  # Assuming FIFO queues
                BATCH_SIZE=$(jq -r '.sqsTrigger.batchSize' "$CONFIG_FILE")
                
                EXISTING_MAPPING=$(aws lambda list-event-source-mappings \
                  --function-name "$FUNCTION_NAME" \
                  --query "EventSourceMappings[?EventSourceArn=='$TENANT_QUEUE_ARN'].UUID" \
                  --output text)
                
                if [ -z "$EXISTING_MAPPING" ]; then
                  echo "Adding tenant-specific SQS trigger for $FUNCTION_NAME..."
                  aws lambda create-event-source-mapping \
                    --function-name "$FUNCTION_NAME" \
                    --batch-size "$BATCH_SIZE" \
                    --event-source-arn "$TENANT_QUEUE_ARN"
                fi
              fi

              echo "Deployment complete for $FUNCTION_NAME"
              sleep 10
            done